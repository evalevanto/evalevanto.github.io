<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Engineering on The Mess Of Nebula</title><link>http://evalevanto.github.io/categories/engineering/</link><description>Recent content in Engineering on The Mess Of Nebula</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 06 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="http://evalevanto.github.io/categories/engineering/index.xml" rel="self" type="application/rss+xml"/><item><title>BHMEACTF22: Secret</title><link>http://evalevanto.github.io/posts/bhmeactf22-secret/</link><pubDate>Thu, 06 Oct 2022 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/bhmeactf22-secret/</guid><description>For the birds ðŸ”— I use pwntools for my scripting. While I will show snippets where relevant, I will share the full script at the end. I will create a follow-up blog on ROP introduction and notify.
Checksec ðŸ”—[*] &amp;#39;/home/levanto/Documents/Return-To-ROP/ChasingFlags/BlackHat/PWN/secret/main&amp;#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled There is a stack canary - which you have to get if you would need to overwrite a return address.</description></item><item><title>AHCTF2021: NameCheck</title><link>http://evalevanto.github.io/posts/ahctf2021-namecheck/</link><pubDate>Sun, 18 Sep 2022 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/ahctf2021-namecheck/</guid><description>For the birds ðŸ”— It has been a while since I have blogged. The importance of doing so has not been absent only outweighed by the inertia(that dread to begin). This is the start of an attempt to put more of my thoughts on e-paper. I also maintain a telegram space where I dump materials/resources I encounter as I go along.
Checksec ðŸ”—[*] &amp;#39;/home/levanto/Documents/Return-To-ROP/ChasingFlags/AHCTF/finals/namecheck&amp;#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments .</description></item><item><title>Snappy on Travis</title><link>http://evalevanto.github.io/posts/snappy-on-travis/</link><pubDate>Sat, 22 May 2021 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/snappy-on-travis/</guid><description>SNAP is a platform for processing and analysis of Earth Observation products. It exposes an interface (SNAP-Python) that enables using the platform in python projects.
This article steps through the process of installing SNAP and configuring a python environment to use SNAP-Python.
Travis dist used: bionic. python version 3.9
This workflow has been tested on multiple linux distros. No thorough test has been done on other *nix
Prerequisites ðŸ”—This process requires some dependencies.</description></item><item><title>MicroCorruption: Jakarta</title><link>http://evalevanto.github.io/posts/microcorruption-jakarta/</link><pubDate>Wed, 04 Nov 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-jakarta/</guid><description>Jakarta Writeup ðŸ”— You finally Gitgit to Jakarta.. ðŸ”—There&amp;rsquo;s a manual:
Passwords that are too long are rejected. There is additional mechanisms to verify password length. The lock is attached to LockIT Pro HSM-1. The main function just calls login.
login function is quite long:
Authentication requires a username and password input. The prompt states that these inputs together may not be more than 32 characters. :D
The gets function for getting the username:</description></item><item><title>MicroCorruption: Santa Cruz</title><link>http://evalevanto.github.io/posts/microcorruption-santa-cruz/</link><pubDate>Wed, 04 Nov 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-santa-cruz/</guid><description>Santa Cruz Writeup ðŸ”— Cali-ng in! ðŸ”—Nice! Here is a lock. This is the manual:
Passwords that are too long are rejected. There is not much clues from the manual.
The main function just calls the login function:
Authentication requires a username and password input. The prompt states that these inputs should be between 8 and 16 chars. :D
Bytes 0x0, 0x8 and 0x10 are set into the addresses at r4 - (0x6, 0x19,0x18) respectively.</description></item><item><title>MicroCorruption: Novosibirsk</title><link>http://evalevanto.github.io/posts/microcorruption-novosibirsk/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-novosibirsk/</guid><description>Novosibirsk Writeup ðŸ”— Novody is home&amp;hellip; ðŸ”—but a manual:
The lock is attached to LockIT Pro HSM-2. Features have been added from the b.03 to the hardware. Passwords can not be too long. So this hardware version differs from b.03 in that HSM-2 is what is connected to port 2.
Also, passwords cannot be too long. Mmmh?
The main function:
The input buffer for username:
r14: Holds the length of the input buffer: 0x1f4 (500) characters.</description></item><item><title>MicroCorruption: Addis Ababa</title><link>http://evalevanto.github.io/posts/microcorruption-addis-ababa/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-addis-ababa/</guid><description>Addis Ababa Writeup ðŸ”— Ab..about last night! ðŸ”—You get to Addis Ababa and find a lock with a manual:
The lock is attached to HSM-1 module. Passwords cannot be too long. Usernames are printed back. Flag set in memory if password is correct. Usernames are printed back. This must be a clue. You think of format string vulnerabilities. Note to self: Printf!!
This is the main function:
r14: the length of the input buffer is #0x13(19) characters.</description></item><item><title>MicroCorruption: Johannesburg</title><link>http://evalevanto.github.io/posts/microcorruption-johannesburg/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-johannesburg/</guid><description>Johannesburg Writeup ðŸ”— We in satafrica! :D ðŸ”—At this point in the journey, you expect a manual to greet you:
The lock is attached to HSM-1 module. Passwords that are very long are rejected. Just how long is too long? The main function just calls login.
The prompt states the password range should be within 8 - 16 characters long. However, from the input parameters of the getsn function:
r14: Holds length of the input buffer; 0x3f(63) characters.</description></item><item><title>MicroCorruption: Montevideo</title><link>http://evalevanto.github.io/posts/microcorruption-montevideo/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-montevideo/</guid><description>Montevideo Writeup ðŸ”— On Uruguay to unlock Montevideo&amp;hellip; ðŸ”—You find a manual:
This lock is attached to HSM-2 module. This means, no unlock door function in the lock firmware. This reminds you of a while back in WhiteHorse. The code follows internal secure development process. mmh. The main function just calls login.
The prompt states for an input range of 8 - 16 characters. However, from the input to getsn function:</description></item><item><title>MicroCorruption: Reykjavik</title><link>http://evalevanto.github.io/posts/microcorruption-reykjavik/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-reykjavik/</guid><description>Reykjavik Writeup ðŸ”— One cool plaice, Reykjavik :) ðŸ”—Military-grade security lock they say. Here is the manual:
This lock is not attached to any HSM module. Military-grade on-device encryption has been implemented to keep the password secure. Passwords entered cannot be read from memory. This is the main function:
Interesting findings:
A block of opcode: beginning from 0x4520 spanning for 0xf8 is passed to enc function. The destination of the result is set for #0x2400.</description></item><item><title>MicroCorruption: Whitehorse</title><link>http://evalevanto.github.io/posts/microcorruption-whitehorse/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-whitehorse/</guid><description>Whitehorse Writeup ðŸ”— Haaay! &amp;hellip; Neigh? ðŸ”—Slaps you with a manual:
This lock is attached to a HSM-2 module. Function to unlock door no longer in the lock firmware. The main function just calls login. You set a breakpoint at login and a quick test input of aaaaaaaaaaaaaaaa
The login function:
The prompt gives a range for input to be between 8 to 16 characters. However, the parameters for the getsn function: r14: Holds the length of the input buffer.</description></item><item><title>MicroCorruption: Cusco</title><link>http://evalevanto.github.io/posts/microcorruption-cusco/</link><pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-cusco/</guid><description>Cusco Writeup ðŸ”— Cusco!! ðŸ”— In this manual, you notice that:
This lock is attached to HSM-1 module. The conditional flag that accidentally gets set when very long passwords are put in, has been removed. After a fast fail using a test input: aaaaaaaaaaaaaaaa, turns out the program does not exit. It instead, loops back to the start of the program.
This is interesting. Why? Because it is a clue that at some point at the end of a failed password verification; instead of a program exit, the return address points to the beginning instruction to jump to.</description></item><item><title>MicroCorruption: Hanoi</title><link>http://evalevanto.github.io/posts/microcorruption-hanoi/</link><pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-hanoi/</guid><description>Hanoi Writeup ðŸ”— Hanoi, hanoi; what doth thou have in store. ðŸ”—You get to Hanoi, you find a manual.
Things are a bit different this time:
This Lock is attached to LockIT Pro HSM-1. Password stored in the HSM. Password set by connecting to app through the HSM and restarting the Lock. A flag is set by the HSM after validating a correct password input. The main function just calls the login function.</description></item><item><title>MicroCorruption: New Orleans</title><link>http://evalevanto.github.io/posts/microcorruption-new-orleans/</link><pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-new-orleans/</guid><description>New Orleans Writeup ðŸ”— This is the first destination you get to explore. ðŸ”—You find a manual for the LockIT Pro Lock:
You learn some things from the manual:
It is not attached to a HSM module. Password set by entering it on the app restarting the lock. You are presented with a live debugger, a live memory dump, a disassembler and a view of the register states.
Looking through the main you notice a create_password function that gets called before the input is required or a check for correct input is done.</description></item><item><title>MicroCorruption: Sydney</title><link>http://evalevanto.github.io/posts/microcorruption-sydney/</link><pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-sydney/</guid><description>Sydney Writeup ðŸ”— Second destination, you find yourself in Sydney. ðŸ”—Another LockIT Pro Lock manual but this is a more secure, revised version they say ;) :
You learn that:
The lock is not attached to a HSM(Hardware Security Module). The password is now not stored in memory. This is how the main function looks like:
There is a check_password function called. You do the usual quick run of the program using a dummy input test, set a breakpoint on check_password and follow through the flow.</description></item><item><title>GDAL on Travis</title><link>http://evalevanto.github.io/posts/gdal-on-travis/</link><pubDate>Wed, 25 Mar 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/gdal-on-travis/</guid><description>GDAL on Travis ðŸ”— This article is meant to be a relative process guide on issues around installing GDAL on Travis CI. Frustrations around finding helpful articles have led to this writing. The steps follow an error reproduction to a solid solution for the issue.
The GDAL version installed on the chosen machine must match the package library version installed into your project. Example, glad-config -v == pip freeze | grep GDAL.</description></item><item><title>AH19CTF WriteUps: Command Parser</title><link>http://evalevanto.github.io/posts/ah19ctf-writeups-command-parser/</link><pubDate>Sat, 17 Aug 2019 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/ah19ctf-writeups-command-parser/</guid><description>What&amp;rsquo;s provided: ðŸ”— Server access to a directory containing an executable and a flag file. You cannot just cat flag because r--r----- 1 commandparserctf-pwn root ... flag and of course, your whoami profile is not in the sudoers list.
A link to download the executable file. This is good. You can dissassemble it later.
Let&amp;rsquo;s get cracking :D ðŸ”—Your first step is to run the executable and have a clue of what it does.</description></item></channel></rss>