<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Micro Corruption on The Mess Of Nebula</title><link>http://evalevanto.github.io/categories/micro-corruption/</link><description>Recent content in Micro Corruption on The Mess Of Nebula</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Â© 2023 Eva Levanto</copyright><lastBuildDate>Wed, 04 Nov 2020 00:00:00 +0000</lastBuildDate><atom:link href="http://evalevanto.github.io/categories/micro-corruption/index.xml" rel="self" type="application/rss+xml"/><item><title>MicroCorruption: Jakarta</title><link>http://evalevanto.github.io/posts/microcorruption-jakarta/</link><pubDate>Wed, 04 Nov 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-jakarta/</guid><description>There&amp;rsquo;s a manual:
Passwords that are too long are rejected. There is additional mechanisms to verify password length. The lock is attached to LockIT Pro HSM-1. The main function just calls login.
login function is quite long:
Authentication requires a username and password input. The prompt states that these inputs together may not be more than 32 characters. :D
The gets function for getting the username:
length of input buffer: held at r14 -&amp;gt; 0xff(255) characters.</description></item><item><title>MicroCorruption: Santa Cruz</title><link>http://evalevanto.github.io/posts/microcorruption-cruz/</link><pubDate>Wed, 04 Nov 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-cruz/</guid><description>Nice! Here is a lock. This is the manual:
Passwords that are too long are rejected. There is not much clues from the manual.
The main function just calls the login function:
Authentication requires a username and password input. The prompt states that these inputs should be between 8 and 16 chars. :D
Bytes 0x0, 0x8 and 0x10 are set into the addresses at r4 - (0x6, 0x19,0x18) respectively. This will probably make sense soon.</description></item><item><title>MicroCorruption: Novosibirsk</title><link>http://evalevanto.github.io/posts/microcorruption-novo/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-novo/</guid><description>but a manual:
The lock is attached to LockIT Pro HSM-2. Features have been added from the b.03 to the hardware. Passwords can not be too long. So this hardware version differs from b.03 in that HSM-2 is what is connected to port 2.
Also, passwords cannot be too long. Mmmh?
The main function:
The input buffer for username:
r14: Holds the length of the input buffer: 0x1f4 (500) characters.</description></item><item><title>MicroCorruption: Addis Ababa</title><link>http://evalevanto.github.io/posts/microcorruption-addis/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-addis/</guid><description>You get to Addis Ababa and find a lock with a manual:
The lock is attached to HSM-1 module. Passwords cannot be too long. Usernames are printed back. Flag set in memory if password is correct. Usernames are printed back. This must be a clue. You think of format string vulnerabilities. Note to self: Printf!!
This is the main function:
r14: the length of the input buffer is #0x13(19) characters.</description></item><item><title>MicroCorruption: Johannesburg</title><link>http://evalevanto.github.io/posts/microcorruption-jo/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-jo/</guid><description>At this point in the journey, you expect a manual to greet you:
The lock is attached to HSM-1 module. Passwords that are very long are rejected. Just how long is too long? The main function just calls login.
The prompt states the password range should be within 8 - 16 characters long. However, from the input parameters of the getsn function:
r14: Holds length of the input buffer; 0x3f(63) characters.</description></item><item><title>MicroCorruption: Montevideo</title><link>http://evalevanto.github.io/posts/microcorruption-monte/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-monte/</guid><description>You find a manual:
This lock is attached to HSM-2 module. This means, no unlock door function in the lock firmware. This reminds you of a while back in WhiteHorse. The code follows internal secure development process. mmh. The main function just calls login.
The prompt states for an input range of 8 - 16 characters. However, from the input to getsn function:
r14: this holds the length of the input buffer; 0x30(48) characters.</description></item><item><title>MicroCorruption: Reykjavik</title><link>http://evalevanto.github.io/posts/microcorruption-reykjavik/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-reykjavik/</guid><description>Military-grade security lock they say. Here is the manual:
This lock is not attached to any HSM module. Military-grade on-device encryption has been implemented to keep the password secure. Passwords entered cannot be read from memory. This is the main function:
Interesting findings:
A block of opcode: beginning from 0x4520 spanning for 0xf8 is passed to enc function. The destination of the result is set for #0x2400.
The enc function basically interchanges the opcode for the one destination to the other using some operations to determine the address (you decide to save the details for this; you can inspect it later).</description></item><item><title>MicroCorruption: Whitehorse</title><link>http://evalevanto.github.io/posts/microcorruption-whitehorse/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-whitehorse/</guid><description>Slaps you with a manual:
This lock is attached to a HSM-2 module. Function to unlock door no longer in the lock firmware. The main function just calls login. You set a breakpoint at login and a quick test input of aaaaaaaaaaaaaaaa
The login function:
The prompt gives a range for input to be between 8 to 16 characters. However, the parameters for the getsn function: r14: Holds the length of the input buffer.</description></item><item><title>MicroCorruption: Cusco</title><link>http://evalevanto.github.io/posts/microcorruption-cusco/</link><pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-cusco/</guid><description>In this manual, you notice that:
This lock is attached to HSM-1 module. The conditional flag that accidentally gets set when very long passwords are put in, has been removed. After a fast fail using a test input: aaaaaaaaaaaaaaaa, turns out the program does not exit. It instead, loops back to the start of the program.
This is interesting. Why? Because it is a clue that at some point at the end of a failed password verification; instead of a program exit, the return address points to the beginning instruction to jump to.</description></item><item><title>MicroCorruption: Hanoi</title><link>http://evalevanto.github.io/posts/microcorruption-hanoi/</link><pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-hanoi/</guid><description>You get to Hanoi, you find a manual.
Things are a bit different this time:
This Lock is attached to LockIT Pro HSM-1. Password stored in the HSM. Password set by connecting to app through the HSM and restarting the Lock. A flag is set by the HSM after validating a correct password input. The main function just calls the login function. The prompt for writing your test input gives an interesting clue: the password range.</description></item><item><title>MicroCorruption: New Orleans</title><link>http://evalevanto.github.io/posts/microcorruption-new-orleans/</link><pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-new-orleans/</guid><description>You find a manual for the LockIT Pro Lock:
You learn some things from the manual:
It is not attached to a HSM module. Password set by entering it on the app restarting the lock. You are presented with a live debugger, a live memory dump, a disassembler and a view of the register states.
Looking through the main you notice a create_password function that gets called before the input is required or a check for correct input is done.</description></item><item><title>MicroCorruption: Sydney</title><link>http://evalevanto.github.io/posts/microcorruption-sydney/</link><pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-sydney/</guid><description>Another LockIT Pro Lock manual but this is a more secure, revised version they say ;) :
You learn that:
The lock is not attached to a HSM(Hardware Security Module). The password is now not stored in memory. This is how the main function looks like:
There is a check_password function called. You do the usual quick run of the program using a dummy input test, set a breakpoint on check_password and follow through the flow.</description></item></channel></rss>