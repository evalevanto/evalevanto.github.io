<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Reverse Engineering on The Mess Of Nebula</title><link>http://evalevanto.github.io/categories/reverse-engineering/</link><description>Recent content in Reverse Engineering on The Mess Of Nebula</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Â© 2023 Eva Levanto</copyright><lastBuildDate>Tue, 26 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="http://evalevanto.github.io/categories/reverse-engineering/index.xml" rel="self" type="application/rss+xml"/><item><title>SHCTF23: Magic Trick</title><link>http://evalevanto.github.io/posts/magic_trick/</link><pubDate>Tue, 26 Sep 2023 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/magic_trick/</guid><description>Description: Sometimes, what&amp;rsquo;s white is merely a canvas awaiting its story. Recall the artist&amp;rsquo;s technique from the age of angels, and you might unveil a tale hidden in code.
This was a fun puzzle! ðŸ˜ƒ
You are given a executable file and a blank white png file.
Binary analysis â””â”€$ file magic magic: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=3dfe013b3027047470d1aac10a3504baf6969725, for GNU/Linux 2.6.32, stripped objdump -sj .</description></item><item><title>BHMEACTF22: Secret</title><link>http://evalevanto.github.io/posts/secret/</link><pubDate>Thu, 06 Oct 2022 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/secret/</guid><description>For the birds I use pwntools for my scripting. While I will show snippets where relevant, I will share the full script at the end.
I will create a follow-up blog on ROP introduction and notify.
Checksec [*] &amp;#39;/home/levanto/Documents/Return-To-ROP/ChasingFlags/BlackHat/PWN/secret/main&amp;#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled There is a stack canary - which you have to get if you would need to overwrite a return address.</description></item><item><title>AHCTF2021: NameCheck</title><link>http://evalevanto.github.io/posts/namecheck/</link><pubDate>Sun, 18 Sep 2022 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/namecheck/</guid><description>For the birds It has been a while since I have blogged. The importance of doing so has not been absent only outweighed by the inertia(that dread to begin). This is the start of an attempt to put more of my thoughts on e-paper. I also maintain a telegram space where I dump materials/resources I encounter as I go along.
Checksec [*] &amp;#39;/home/levanto/Documents/Return-To-ROP/ChasingFlags/AHCTF/finals/namecheck&amp;#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments .</description></item><item><title>MicroCorruption: Jakarta</title><link>http://evalevanto.github.io/posts/microcorruption-jakarta/</link><pubDate>Wed, 04 Nov 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-jakarta/</guid><description>There&amp;rsquo;s a manual:
Passwords that are too long are rejected. There is additional mechanisms to verify password length. The lock is attached to LockIT Pro HSM-1. The main function just calls login.
login function is quite long:
Authentication requires a username and password input. The prompt states that these inputs together may not be more than 32 characters. :D
The gets function for getting the username:
length of input buffer: held at r14 -&amp;gt; 0xff(255) characters.</description></item><item><title>MicroCorruption: Santa Cruz</title><link>http://evalevanto.github.io/posts/microcorruption-cruz/</link><pubDate>Wed, 04 Nov 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-cruz/</guid><description>Nice! Here is a lock. This is the manual:
Passwords that are too long are rejected. There is not much clues from the manual.
The main function just calls the login function:
Authentication requires a username and password input. The prompt states that these inputs should be between 8 and 16 chars. :D
Bytes 0x0, 0x8 and 0x10 are set into the addresses at r4 - (0x6, 0x19,0x18) respectively. This will probably make sense soon.</description></item><item><title>MicroCorruption: Novosibirsk</title><link>http://evalevanto.github.io/posts/microcorruption-novo/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-novo/</guid><description>but a manual:
The lock is attached to LockIT Pro HSM-2. Features have been added from the b.03 to the hardware. Passwords can not be too long. So this hardware version differs from b.03 in that HSM-2 is what is connected to port 2.
Also, passwords cannot be too long. Mmmh?
The main function:
The input buffer for username:
r14: Holds the length of the input buffer: 0x1f4 (500) characters.</description></item><item><title>MicroCorruption: Addis Ababa</title><link>http://evalevanto.github.io/posts/microcorruption-addis/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-addis/</guid><description>You get to Addis Ababa and find a lock with a manual:
The lock is attached to HSM-1 module. Passwords cannot be too long. Usernames are printed back. Flag set in memory if password is correct. Usernames are printed back. This must be a clue. You think of format string vulnerabilities. Note to self: Printf!!
This is the main function:
r14: the length of the input buffer is #0x13(19) characters.</description></item><item><title>MicroCorruption: Johannesburg</title><link>http://evalevanto.github.io/posts/microcorruption-jo/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-jo/</guid><description>At this point in the journey, you expect a manual to greet you:
The lock is attached to HSM-1 module. Passwords that are very long are rejected. Just how long is too long? The main function just calls login.
The prompt states the password range should be within 8 - 16 characters long. However, from the input parameters of the getsn function:
r14: Holds length of the input buffer; 0x3f(63) characters.</description></item><item><title>MicroCorruption: Montevideo</title><link>http://evalevanto.github.io/posts/microcorruption-monte/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-monte/</guid><description>You find a manual:
This lock is attached to HSM-2 module. This means, no unlock door function in the lock firmware. This reminds you of a while back in WhiteHorse. The code follows internal secure development process. mmh. The main function just calls login.
The prompt states for an input range of 8 - 16 characters. However, from the input to getsn function:
r14: this holds the length of the input buffer; 0x30(48) characters.</description></item><item><title>MicroCorruption: Reykjavik</title><link>http://evalevanto.github.io/posts/microcorruption-reykjavik/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-reykjavik/</guid><description>Military-grade security lock they say. Here is the manual:
This lock is not attached to any HSM module. Military-grade on-device encryption has been implemented to keep the password secure. Passwords entered cannot be read from memory. This is the main function:
Interesting findings:
A block of opcode: beginning from 0x4520 spanning for 0xf8 is passed to enc function. The destination of the result is set for #0x2400.
The enc function basically interchanges the opcode for the one destination to the other using some operations to determine the address (you decide to save the details for this; you can inspect it later).</description></item><item><title>MicroCorruption: Whitehorse</title><link>http://evalevanto.github.io/posts/microcorruption-whitehorse/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-whitehorse/</guid><description>Slaps you with a manual:
This lock is attached to a HSM-2 module. Function to unlock door no longer in the lock firmware. The main function just calls login. You set a breakpoint at login and a quick test input of aaaaaaaaaaaaaaaa
The login function:
The prompt gives a range for input to be between 8 to 16 characters. However, the parameters for the getsn function: r14: Holds the length of the input buffer.</description></item><item><title>MicroCorruption: Cusco</title><link>http://evalevanto.github.io/posts/microcorruption-cusco/</link><pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-cusco/</guid><description>In this manual, you notice that:
This lock is attached to HSM-1 module. The conditional flag that accidentally gets set when very long passwords are put in, has been removed. After a fast fail using a test input: aaaaaaaaaaaaaaaa, turns out the program does not exit. It instead, loops back to the start of the program.
This is interesting. Why? Because it is a clue that at some point at the end of a failed password verification; instead of a program exit, the return address points to the beginning instruction to jump to.</description></item><item><title>MicroCorruption: Hanoi</title><link>http://evalevanto.github.io/posts/microcorruption-hanoi/</link><pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-hanoi/</guid><description>You get to Hanoi, you find a manual.
Things are a bit different this time:
This Lock is attached to LockIT Pro HSM-1. Password stored in the HSM. Password set by connecting to app through the HSM and restarting the Lock. A flag is set by the HSM after validating a correct password input. The main function just calls the login function. The prompt for writing your test input gives an interesting clue: the password range.</description></item><item><title>MicroCorruption: New Orleans</title><link>http://evalevanto.github.io/posts/microcorruption-new-orleans/</link><pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-new-orleans/</guid><description>You find a manual for the LockIT Pro Lock:
You learn some things from the manual:
It is not attached to a HSM module. Password set by entering it on the app restarting the lock. You are presented with a live debugger, a live memory dump, a disassembler and a view of the register states.
Looking through the main you notice a create_password function that gets called before the input is required or a check for correct input is done.</description></item><item><title>MicroCorruption: Sydney</title><link>http://evalevanto.github.io/posts/microcorruption-sydney/</link><pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-sydney/</guid><description>Another LockIT Pro Lock manual but this is a more secure, revised version they say ;) :
You learn that:
The lock is not attached to a HSM(Hardware Security Module). The password is now not stored in memory. This is how the main function looks like:
There is a check_password function called. You do the usual quick run of the program using a dummy input test, set a breakpoint on check_password and follow through the flow.</description></item><item><title>AH19CTF WriteUps: Command Parser</title><link>http://evalevanto.github.io/posts/commandparser/</link><pubDate>Sat, 17 Aug 2019 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/commandparser/</guid><description>What&amp;rsquo;s provided: Server access to a directory containing an executable and a flag file. You cannot just cat flag because r--r----- 1 commandparserctf-pwn root ... flag and of course, your whoami profile is not in the sudoers list.
A link to download the executable file. This is good. You can dissassemble it later.
Let&amp;rsquo;s get cracking :D Your first step is to run the executable and have a clue of what it does.</description></item></channel></rss>