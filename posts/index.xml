<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on The Mess Of Nebula</title><link>http://evalevanto.github.io/posts/</link><description>Recent content in Posts on The Mess Of Nebula</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Â© 2023 Eva Levanto</copyright><lastBuildDate>Sat, 12 Aug 2023 00:00:00 +0000</lastBuildDate><atom:link href="http://evalevanto.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Case 00 â†’ Comme le Chef! ðŸ˜Ž</title><link>http://evalevanto.github.io/posts/case_00/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/case_00/</guid><description>Mission: Dig into the vast archives of our system operation logs from the legendary year 2022. You&amp;rsquo;re on a quest to unearth the absolute legend, the detective with the biggest impact on our businessâ€”the one who raked in the most moolah by claiming bounties like a boss!
For all the marblesâ€¦: Who is the detective that earned most money in 2022?
Create the table.
.execute database script &amp;lt;| .create table DetectiveCases(Timestamp:datetime, EventType:string, DetectiveId:string, CaseId: string, Properties:dynamic) //clear any previously ingested data if such exists .</description></item><item><title>Towards OSCP</title><link>http://evalevanto.github.io/posts/towards-oscp/</link><pubDate>Fri, 09 Jun 2023 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/towards-oscp/</guid><description>Okay, you are going to read that phrase &amp;ldquo;Towards * OSCP&amp;rdquo; before you finish this article.
This article is a meta article :P
I document my journey that began July 2022 to earn the OSCP certification. It is a collection of resources, tips, and tricks to help you get started on the OSCP journey.
The link to the article is here.
Not sure if you will be back here for comments, but if you don&amp;rsquo;t, I hope you find the article helpful.</description></item><item><title>BHMEACTF22: Secret</title><link>http://evalevanto.github.io/posts/secret/</link><pubDate>Thu, 06 Oct 2022 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/secret/</guid><description>For the birds I use pwntools for my scripting. While I will show snippets where relevant, I will share the full script at the end.
I will create a follow-up blog on ROP introduction and notify.
Checksec [*] &amp;#39;/home/levanto/Documents/Return-To-ROP/ChasingFlags/BlackHat/PWN/secret/main&amp;#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled There is a stack canary - which you have to get if you would need to overwrite a return address.</description></item><item><title>AHCTF2021: NameCheck</title><link>http://evalevanto.github.io/posts/namecheck/</link><pubDate>Sun, 18 Sep 2022 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/namecheck/</guid><description>For the birds It has been a while since I have blogged. The importance of doing so has not been absent only outweighed by the inertia(that dread to begin). This is the start of an attempt to put more of my thoughts on e-paper. I also maintain a telegram space where I dump materials/resources I encounter as I go along.
Checksec [*] &amp;#39;/home/levanto/Documents/Return-To-ROP/ChasingFlags/AHCTF/finals/namecheck&amp;#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments .</description></item><item><title>A review: The Pragmatic Programmer</title><link>http://evalevanto.github.io/posts/pragmatic-programmer/</link><pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/pragmatic-programmer/</guid><description>Hello, this is an attempt to condense this classic book to about.. some very less words, hoping to still capture the core of each topic.
The article should be kept as a reference to the important pointers. However, make a point of reading this book: seriously. :crossed_fingers:
Resource: https://bit.ly/2ARPd7e
Chapter 1: A Pragmatic Philosophy We who cut mere stones must always be envisioning cathedrals!
It&amp;rsquo;s a continuous process: coding.</description></item><item><title>Snappy on Travis</title><link>http://evalevanto.github.io/posts/snap_travis/</link><pubDate>Sat, 22 May 2021 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/snap_travis/</guid><description>SNAP is a platform for processing and analysis of Earth Observation products. It exposes an interface (SNAP-Python) that enables using the platform in python projects.
This article steps through the process of installing SNAP and configuring a python environment to use SNAP-Python.
Travis dist used: bionic. python version 3.9
This workflow has been tested on multiple linux distros. No thorough test has been done on other *nix
Prerequisites This process requires some dependencies.</description></item><item><title>MicroCorruption: Jakarta</title><link>http://evalevanto.github.io/posts/microcorruption-jakarta/</link><pubDate>Wed, 04 Nov 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-jakarta/</guid><description>There&amp;rsquo;s a manual:
Passwords that are too long are rejected. There is additional mechanisms to verify password length. The lock is attached to LockIT Pro HSM-1. The main function just calls login.
login function is quite long:
Authentication requires a username and password input. The prompt states that these inputs together may not be more than 32 characters. :D
The gets function for getting the username:
length of input buffer: held at r14 -&amp;gt; 0xff(255) characters.</description></item><item><title>MicroCorruption: Santa Cruz</title><link>http://evalevanto.github.io/posts/microcorruption-cruz/</link><pubDate>Wed, 04 Nov 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-cruz/</guid><description>Nice! Here is a lock. This is the manual:
Passwords that are too long are rejected. There is not much clues from the manual.
The main function just calls the login function:
Authentication requires a username and password input. The prompt states that these inputs should be between 8 and 16 chars. :D
Bytes 0x0, 0x8 and 0x10 are set into the addresses at r4 - (0x6, 0x19,0x18) respectively. This will probably make sense soon.</description></item><item><title>MicroCorruption: Novosibirsk</title><link>http://evalevanto.github.io/posts/microcorruption-novo/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-novo/</guid><description>but a manual:
The lock is attached to LockIT Pro HSM-2. Features have been added from the b.03 to the hardware. Passwords can not be too long. So this hardware version differs from b.03 in that HSM-2 is what is connected to port 2.
Also, passwords cannot be too long. Mmmh?
The main function:
The input buffer for username:
r14: Holds the length of the input buffer: 0x1f4 (500) characters.</description></item><item><title>MicroCorruption: Addis Ababa</title><link>http://evalevanto.github.io/posts/microcorruption-addis/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-addis/</guid><description>You get to Addis Ababa and find a lock with a manual:
The lock is attached to HSM-1 module. Passwords cannot be too long. Usernames are printed back. Flag set in memory if password is correct. Usernames are printed back. This must be a clue. You think of format string vulnerabilities. Note to self: Printf!!
This is the main function:
r14: the length of the input buffer is #0x13(19) characters.</description></item><item><title>MicroCorruption: Johannesburg</title><link>http://evalevanto.github.io/posts/microcorruption-jo/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-jo/</guid><description>At this point in the journey, you expect a manual to greet you:
The lock is attached to HSM-1 module. Passwords that are very long are rejected. Just how long is too long? The main function just calls login.
The prompt states the password range should be within 8 - 16 characters long. However, from the input parameters of the getsn function:
r14: Holds length of the input buffer; 0x3f(63) characters.</description></item><item><title>MicroCorruption: Montevideo</title><link>http://evalevanto.github.io/posts/microcorruption-monte/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-monte/</guid><description>You find a manual:
This lock is attached to HSM-2 module. This means, no unlock door function in the lock firmware. This reminds you of a while back in WhiteHorse. The code follows internal secure development process. mmh. The main function just calls login.
The prompt states for an input range of 8 - 16 characters. However, from the input to getsn function:
r14: this holds the length of the input buffer; 0x30(48) characters.</description></item><item><title>MicroCorruption: Reykjavik</title><link>http://evalevanto.github.io/posts/microcorruption-reykjavik/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-reykjavik/</guid><description>Military-grade security lock they say. Here is the manual:
This lock is not attached to any HSM module. Military-grade on-device encryption has been implemented to keep the password secure. Passwords entered cannot be read from memory. This is the main function:
Interesting findings:
A block of opcode: beginning from 0x4520 spanning for 0xf8 is passed to enc function. The destination of the result is set for #0x2400.
The enc function basically interchanges the opcode for the one destination to the other using some operations to determine the address (you decide to save the details for this; you can inspect it later).</description></item><item><title>MicroCorruption: Whitehorse</title><link>http://evalevanto.github.io/posts/microcorruption-whitehorse/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-whitehorse/</guid><description>Slaps you with a manual:
This lock is attached to a HSM-2 module. Function to unlock door no longer in the lock firmware. The main function just calls login. You set a breakpoint at login and a quick test input of aaaaaaaaaaaaaaaa
The login function:
The prompt gives a range for input to be between 8 to 16 characters. However, the parameters for the getsn function: r14: Holds the length of the input buffer.</description></item><item><title>MicroCorruption: Cusco</title><link>http://evalevanto.github.io/posts/microcorruption-cusco/</link><pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-cusco/</guid><description>In this manual, you notice that:
This lock is attached to HSM-1 module. The conditional flag that accidentally gets set when very long passwords are put in, has been removed. After a fast fail using a test input: aaaaaaaaaaaaaaaa, turns out the program does not exit. It instead, loops back to the start of the program.
This is interesting. Why? Because it is a clue that at some point at the end of a failed password verification; instead of a program exit, the return address points to the beginning instruction to jump to.</description></item><item><title>MicroCorruption: Hanoi</title><link>http://evalevanto.github.io/posts/microcorruption-hanoi/</link><pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-hanoi/</guid><description>You get to Hanoi, you find a manual.
Things are a bit different this time:
This Lock is attached to LockIT Pro HSM-1. Password stored in the HSM. Password set by connecting to app through the HSM and restarting the Lock. A flag is set by the HSM after validating a correct password input. The main function just calls the login function. The prompt for writing your test input gives an interesting clue: the password range.</description></item><item><title>MicroCorruption: New Orleans</title><link>http://evalevanto.github.io/posts/microcorruption-new-orleans/</link><pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-new-orleans/</guid><description>You find a manual for the LockIT Pro Lock:
You learn some things from the manual:
It is not attached to a HSM module. Password set by entering it on the app restarting the lock. You are presented with a live debugger, a live memory dump, a disassembler and a view of the register states.
Looking through the main you notice a create_password function that gets called before the input is required or a check for correct input is done.</description></item><item><title>MicroCorruption: Sydney</title><link>http://evalevanto.github.io/posts/microcorruption-sydney/</link><pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/microcorruption-sydney/</guid><description>Another LockIT Pro Lock manual but this is a more secure, revised version they say ;) :
You learn that:
The lock is not attached to a HSM(Hardware Security Module). The password is now not stored in memory. This is how the main function looks like:
There is a check_password function called. You do the usual quick run of the program using a dummy input test, set a breakpoint on check_password and follow through the flow.</description></item><item><title>GDAL on Travis</title><link>http://evalevanto.github.io/posts/gdal/</link><pubDate>Wed, 25 Mar 2020 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/gdal/</guid><description>Frustrations around finding helpful articles have led to this writing. The steps follow an error reproduction to a solid solution for the issue.
The GDAL version installed on the chosen machine must match the package library version installed into your project. Example, glad-config -v == pip freeze | grep GDAL.
The project runs python3.7 and requires a GDAL version == 2.4.2, though &amp;gt; 2.2.0 would not break it.
At the time of this writing, travis supports the following distros:</description></item><item><title>AH19CTF WriteUps: Command Parser</title><link>http://evalevanto.github.io/posts/commandparser/</link><pubDate>Sat, 17 Aug 2019 00:00:00 +0000</pubDate><guid>http://evalevanto.github.io/posts/commandparser/</guid><description>What&amp;rsquo;s provided: Server access to a directory containing an executable and a flag file. You cannot just cat flag because r--r----- 1 commandparserctf-pwn root ... flag and of course, your whoami profile is not in the sudoers list.
A link to download the executable file. This is good. You can dissassemble it later.
Let&amp;rsquo;s get cracking :D Your first step is to run the executable and have a clue of what it does.</description></item></channel></rss>